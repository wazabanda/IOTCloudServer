{% extends "core/base.html" %} {% block content %}
<style>
    /* Add any additional styles here */
    .custom-background {
      background-color: #3490dc; /* Blue color, change as needed */
    }
  </style>
<h4
  class="mb-4 text-4l font-extrabold leading-none tracking-tight text-gray-900 md:text-5xl lg:text-6xl"
>
  {{device}} Readings
</h4>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<div
  id="chart_container"
  class="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-6"
></div>

{%if has_location_data%}
Has loc
{%endif%}

<div id="buttons">
    

    {% for pin in gpiopins %}
    <div>
      <p>{{ pin.name }} {{ pin.pin }}</p>
      <div class="flex items-center">
        <input type="checkbox" id="toggleButton{{ pin.pin }}" class="hidden">
        <label for="toggleButton{{ pin.pin }}" class="cursor-pointer">
          <div id="toggleButtonContainer{{ pin.pin }}" class="w-12 h-6 bg-gray-300 rounded-full p-1 duration-300 ease-in-out">
            <div id="toggleIndicator{{ pin.pin }}" class="bg-white w-5 h-5 rounded-full shadow-md transform translate-x-0 duration-300 ease-in-out"></div>
          </div>
        </label>
       
      </div>
    </div>
  {% endfor %}
  
</div>

<script>
  const ctx = document.getElementById("myChart");

  const chartsMap = new Map();
  const parentDiv = document.getElementById("chart_container");
  async function fetchData() {
    try {
      const response = await fetch("/api/core/device_logs/{{device.device_id}}");
      const data = await response.json();
      console.log(data);
      // Process the data
      const groupedData = groupBy(data, "data_label");
      console.log(groupedData)
      const labels = [...new Set(data.map((entry) => entry.date_time))];

      // Create or update charts for each data label
      Object.keys(groupedData).forEach((dataLabel) => {
        let myLineChart = chartsMap.get(dataLabel);

        if (!myLineChart) {
          // Filter out labels without matching data
          const filteredLabels = labels.filter((label) =>
            groupedData[dataLabel].some((entry) => entry.date_time === label)
          );

          // Filter out entries with null values
          const filteredData = groupedData[dataLabel].filter(
            (entry) => entry.value !== null
          );

          const chartData = {
            labels: filteredLabels,
            datasets: [
              {
                label: dataLabel,
                data: filteredLabels.map((label) => {
                  const entry = filteredData.find((e) => e.date_time === label);
                  return entry ? entry.value : null;
                }),
                fill: false,
                borderColor: getRandomColor(),
                tension: 0.1,
                pointStyle: false,
              },
            ],
          };

          // Create a canvas element for each chart
          const canvas = document.createElement("canvas");
          const div = document.createElement("div");
          div.appendChild(canvas);
          div.id = "myLineChart-${dataLabel}-div";
          div.classList = "sm:h-full";
          canvas.id = `myLineChart-${dataLabel}`;
          parentDiv.appendChild(div);

          // Create a new Chart.js instance for each canvas
          const ctx = canvas.getContext("2d");
          myLineChart = new Chart(ctx, {
            type: "line",
            data: chartData,
            options: {
              scales: {
                y: {
                  beginAtZero: true,
                },
              },
            },
          });

          // Store the chart in the map
          chartsMap.set(dataLabel, myLineChart);
        } else {
          // Update the existing chart with new data
          myLineChart.data.labels = labels.filter((label) =>
            groupedData[dataLabel].some((entry) => entry.date_time === label)
          );
          myLineChart.data.datasets[0].data = myLineChart.data.labels.map(
            (label) => {
              const entry = groupedData[dataLabel].find(
                (e) => e.date_time === label
              );
              return entry ? entry.value : null;
            }
          );

          // Update the chart
          myLineChart.update();
        }
      });
    } catch (error) {
      console.error("Error fetching data:", error);
    }
  }

  // Function to group an array of objects by a specific key
  function groupBy(arr, key) {
    return arr.reduce((acc, obj) => {
      const groupKey = obj[key];
      acc[groupKey] = acc[groupKey] || [];
      acc[groupKey].push(obj);
      return acc;
    }, {});
  }

  // Function to get a random color
  function getRandomColor() {
    const letters = "0123456789ABCDEF";
    let color = "#";
    for (let i = 0; i < 6; i++) {
      color += letters[Math.floor(Math.random() * 16)];
    }

    // Add alpha (opacity) value, e.g., '80' corresponds to 50% opacity
    color += "80";

    return color;
  }

  // ... rest of your code ...

  // Fetch data initially
  fetchData();

  // Fetch data every minute

  setInterval(fetchData, 60000 / 12);
</script>

<button id="sendButton">Send Message</button>
<div id="serverResponse"></div>


{% endblock content %}
